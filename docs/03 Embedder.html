---

title: 03 Embedder


keywords: fastai
sidebar: home_sidebar

summary: "At the heart of FRED: the flow embedder. "
description: "At the heart of FRED: the flow embedder. "
nb_path: "03 Model and Loss Functions/03 Embedder.ipynb"
---
<!--

#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: 03 Model and Loss Functions/03 Embedder.ipynb
# command to build the docs after a change: nbdev_build_docs

-->

<div class="container" id="notebook-container">
        
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>FRED's embedder is pretty simple. Given a directed graph along with the coordinates that gave rise to the nodes, FRED embeds it into a lower dimensional space with an autoencoder. FRED also draws a vector field on the embedding space, to endow the embedded points with a sense of flow -- recreating the flows over the directed graph from which they came. FRED is rewarded for drawing arrows such that the flows in the embedding space mimic the flows in the ambient space. And, to give the visualization desirable properties, he is given bonus points for drawing flows that are as smooth as possible - and also placing the points in such a way that they resemble the directed diffusion map. The result is an embedding of the points and velocities that "respects the flow" by incorporating flow information into the placement of points.</p>
<p>This can also be done <em>without</em> the coordinates of the nodes -- e.g. when we have an abstract directed graph, unencumbered by physical coordinates. In this case, a GNN serves as the graph embedder that creates embedding coordinates from the input graph. This is implemented as a separate network.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="Manifold-with-Flow-Embedder">Manifold with Flow Embedder<a class="anchor-link" href="#Manifold-with-Flow-Embedder"> </a></h1>
</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="ManifoldFlowEmbedder" class="doc_header"><code>class</code> <code>ManifoldFlowEmbedder</code><a href="https://github.com/professorwug/FRED/tree/master/FRED/embed.py#L14" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>ManifoldFlowEmbedder</code>(<strong><code>embedding_dimension</code></strong>=<em><code>2</code></em>, <strong><code>embedder_shape</code></strong>=<em><code>[3, 4, 8, 4, 2]</code></em>, <strong><code>device</code></strong>=<em><code>device(type='cpu')</code></em>, <strong><code>sigma</code></strong>=<em><code>0.5</code></em>, <strong><code>flow_strength</code></strong>=<em><code>0.5</code></em>, <strong><code>num_negative_samples</code></strong>=<em><code>20</code></em>, <strong><code>smoothness_grid</code></strong>=<em><code>True</code></em>) :: <code>Module</code></p>
</blockquote>
<p>Base class for all neural network modules.</p>
<p>Your models should also subclass this class.</p>
<p>Modules can also contain other Modules, allowing to nest them in
a tree structure. You can assign the submodules as regular attributes::</p>

<pre><code>import torch.nn as nn
import torch.nn.functional as F

class Model(nn.Module):
    def __init__(self):
        super().__init__()
        self.conv1 = nn.Conv2d(1, 20, 5)
        self.conv2 = nn.Conv2d(20, 20, 5)

    def forward(self, x):
        x = F.relu(self.conv1(x))
        return F.relu(self.conv2(x))

</code></pre>
<p>Submodules assigned in this way will be registered, and will have their
parameters converted too when you call :meth:<code>to</code>, etc.</p>
<p>.. note::
    As per the example above, an <code>__init__()</code> call to the parent class
    must be made before assignment on the child.</p>
<p>:ivar training: Boolean represents whether this module is in training or
                evaluation mode.
:vartype training: bool</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

</div>
 

