---

title: The Flashlight Kernel


keywords: fastai
sidebar: home_sidebar



nb_path: "02a Flashlight Kernel.ipynb"
---
<!--

#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: 02a Flashlight Kernel.ipynb
# command to build the docs after a change: nbdev_build_docs

-->

<div class="container" id="notebook-container">
        
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>FRED at its core is a diffusion-based model; It embeds directed graphs and high dimensional data into euclidean space with a vector field in terms of probabilities, rather than distances. The Flashlight Kernel is a basis of FRED as it translates points and vectors and points in euclidean space with a vector field into affinities between directed graph nodes.</p>
<hr>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="The-Flashlight-Kernel">The Flashlight Kernel<a class="anchor-link" href="#The-Flashlight-Kernel"> </a></h2><p>{% raw %}
$$k(x_i,x_j) = \exp\left[\frac{-\left(||x_j - x_i||_2 + \beta \cdot \left(||v_i||_2 - \left\langle v_i, \frac{x_j - x_i}{||x_j - x_i||_2}\right\rangle \right)\right)}{\sigma}\right],$$
{% endraw %}</p>
<p>where $k(x_i,x_j)$ is the affinity from $x_i$ to $x_j$, $v_i$ is the flow at $x_i$ (vector associated with data point in ambient space or vector at point $x_i$ in embedding space with a vector field), and $||\cdot||_2$ is the regular two-norm. $\beta$ and $\sigma$ are tunable hyperparameters, which controls the emphasis or "strength" of flow relative to distance in the calculation of affinities between two points.</p>
<hr>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>The Flashlight Kernel shows up in various parts of all iterations and implementations of FRED including but not limited to converting high dimensional input data (data clouds with vectors associated to each data points such as RNA Velocity data) into directed graphs with affinities, converting points in our embedding space (euclidean space with a vector field) into directed graphs with affinities, calculating near neighbors of data points in the ambient space, and more.</p>
<p>The essence of the Flashlight Kernel is to retain asymmetric relationships between data points with directionality similar to that of directed graph nodes. It assigns affinities between two data points by considering both the distance between them and their associated vectors; Going with the flow is highly encouraged and going against or even perpendicular to the flow is discouraged and assigned affinity close to zero. As a result, diffusion or random walks probabilities from data point to data point is heavily dictated by the flow in the embedding space or vectors associated with data points in embient space.</p>
<p>Note that affinities between data points can be (and almost always are) asymmetric i.e., $k(x_i, x_j) \neq k(x_j, x_i)$ as the flow at $x_i$ may be pointing towards $x_j$, but the opposite may not be true. In fact, in single-cell data, this is rarely true as cells do not transition back and forth between two different states.</p>
<hr>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="The-Algorithm">The Algorithm<a class="anchor-link" href="#The-Algorithm"> </a></h2><p>$\textbf{Affinity from flow}$</p>
<p>Input:</p>
<ul>
<li>F: $n \times d$ tensor with $n$ rows of points each with flow in $d$  column directions</li>
<li>D: $n \times n \times d$ tensor where dimension 1 represents directions to point i, dimension 2 represents direction from point j, and dimension 3 represents the displacement from point j to point i in each dimension of ($\mathbb{R}^d$). Ex. directions_array[i][j] is the vector from point $x_j$ to point $x_i$ i.e., $(x_j - x_i)$.</li>
<li>b: flow strength ($\beta$)</li>
<li>s: bandwidth ($\sigma$)</li>
</ul>
<p>Algorithm:</p>
<ol>
<li>Calculate length of direction vectors, $L$ ($n \times n$).</li>
<li>Calculate normalized directions tensor from $D$, $D_n$ (n \times n \times d).</li>
<li>Compute dot product between normed directions and flows (Sum $d$ dimensions of $D_nF$ = $C_F$ (cost from flow)).</li>
<li>Subtract $C_F$ from length of flows in $F$ ($F_F$, flow factor).</li>
<li>Take absoluate value of $F_F$.</li>
<li>Add $L$ and $s \cdot F_F$ ($C_{wF}$, cost with flow)</li>
<li>Exponentiate $C_{wF}^T$</li>
</ol>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="affinity_from_flow" class="doc_header"><code>affinity_from_flow</code><a href="https://github.com/professorwug/FRED/tree/master/FRED/data_processing.py#L13" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>affinity_from_flow</code>(<strong><code>flow</code></strong>, <strong><code>directions_array</code></strong>, <strong><code>flow_strength</code></strong>=<em><code>1</code></em>, <strong><code>sigma</code></strong>=<em><code>1</code></em>)</p>
</blockquote>
<p>Compute probabilities of transition in the given directions based on the flow.</p>
<h2 id="Parameters">Parameters<a class="anchor-link" href="#Parameters"> </a></h2><p>flow : torch tensor of shape n_points x n_dims
    <em>description</em>
directions_array : torch tensor of shape n_directions x n_points x n_dims. Assumed to be normalized.
    <em>description</em>
sigma : int, optional
    kernel bandwidth, by default 1
returns (n_points)</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="affinity_matrix_from_pointset_to_pointset" class="doc_header"><code>affinity_matrix_from_pointset_to_pointset</code><a href="https://github.com/professorwug/FRED/tree/master/FRED/data_processing.py#L59" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>affinity_matrix_from_pointset_to_pointset</code>(<strong><code>pointset1</code></strong>, <strong><code>pointset2</code></strong>, <strong><code>flow</code></strong>, <strong><code>n_neighbors</code></strong>=<em><code>None</code></em>, <strong><code>sigma</code></strong>=<em><code>0.5</code></em>, <strong><code>flow_strength</code></strong>=<em><code>1</code></em>)</p>
</blockquote>
<p>Compute affinity matrix between the points of pointset1 and pointset2, using the provided flow.</p>
<h2 id="Parameters">Parameters<a class="anchor-link" href="#Parameters"> </a></h2><p>pointset1 : torch tensor, n1 x d
    The first pointset, to calculate affinities <em>from</em>
pointset2 : torch tensor, n2 x d
    The second pointset, to calculate affinities <em>to</em> (from pointset1)
flow : a function that, when called at a point, gives the flow at that point
n_neighbors : number of neighbors to include in affinity computations. All neighbors beyond it are given affinity zero
(currently not implemented)</p>
<p>Returns:
Affinity matrix: torch tensor of shape n1 x n2</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

</div>


