---

title: EEEMD: Edge-to-Edge Earth Mover's Distance


keywords: fastai
sidebar: home_sidebar

summary: "EMD between graphs with same number of nodes"
description: "EMD between graphs with same number of nodes"
nb_path: "nbs/02 Data Utils - Kernels and Diffusion/02e Edge to Edge Earth Mover's Distance (EEEMD).ipynb"
---
<!--

#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: nbs/02 Data Utils - Kernels and Diffusion/02e Edge to Edge Earth Mover's Distance (EEEMD).ipynb
# command to build the docs after a change: nbdev_build_docs

-->

<div class="container" id="notebook-container">
        
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>We want a distance between graphs with the same number of nodes, obeying:</p>
<ol>
<li>The cost of moving an edge from one neighbor to another neighbor is lower than the cost of moving it from a neighbor to a non-neighbor.</li>
<li>The distance between a pair of edges having one point in common is smaller than the distance between a pair of edges having no points in common.</li>
<li>The above differences in magnitude correspond to the geodesic (manifold) distances on the graph.</li>
</ol>
<p>Such a distance could be useful to FRED. We've previously used the KLD between adjacency matrices as a proxy for this graph-to-graph distance, but the KLD doesn't respect the graph geometry â€” all edges are equally far apart. As a result, gradients flowing from the KLD can't give as useful information to the model -- insofar as <em>which</em> way to tweak the edges or move the nodes -- as might the mythical EEEMD.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="City-block-EEEMD">City-block EEEMD<a class="anchor-link" href="#City-block-EEEMD"> </a></h2><p>Here's one very simple such metric satisfying the above. Let $e_{ij}$ denote the edge between $i$ and $j$. Then we define the distance as:</p>
<p>Neighboring edges (those which share one node) have distance equal to the transport cost between the nodes that they don't share:
{% raw %}
$$d(e_{ij}, e_{ik}) = d_{graph}(j,k)$$
{% endraw %}</p>
<p>By the triangle inequality, other edges have distance less than or equal to the distance obtained by moving one node to a neighboring node and then moving the other:
{% raw %}
$$d(e_{ij},e_{kl}) \leq d(e_{ij}, e_{kj}) + d(e_{kj},e_{kl})$$
{% endraw %}</p>
<p>We'll go ahead and declare this a city-block style metric, in which this distance is equal
{% raw %}
$$d(e_{ij},e_{kl}) = \text{min}(d(e_{ij}, e_{kj}) + d(e_{kj},e_{jl}), d(e_{ij}, e_{il}) + d(e_{il},e_{kl}))$$
{% endraw %}</p>
<p>This defines a distance metric between pairs of edges. Using this as a <em>ground</em> distance over the adjacency matrix, we define the City-block EEMD as the EMD between the adjacency matrices under the cityblock edge-to-edge ground distance.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">from</span> <span class="nn">scipy.sparse</span> <span class="kn">import</span> <span class="n">csr_array</span>
<span class="k">def</span> <span class="nf">EEEMD_cityblock</span><span class="p">(</span><span class="n">A1</span><span class="p">,</span> <span class="n">A2</span><span class="p">,</span> <span class="n">Dgraph</span><span class="p">):</span>
    <span class="c1"># Calculate edge-to-edge ground distance</span>
    <span class="c1"># Support sparse matrices for more efficient computation: we only care </span>
    <span class="c1"># First, calculate distances between neighbors.</span>
    <span class="c1"># Get nonzero combined indices; we only care about these distances</span>
    <span class="n">nonzero_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">csr_array</span><span class="p">(</span><span class="n">A1</span> <span class="o">+</span> <span class="n">A2</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">nonzero_indices</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">from</span> <span class="nn">FRED.graph_datasets</span> <span class="kn">import</span> <span class="n">CycleGraph</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">CycleGraph</span><span class="p">(</span><span class="n">num_nodes</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_text output_error">
<pre>
<span class="ansi-red-fg">---------------------------------------------------------------------------</span>
<span class="ansi-red-fg">ModuleNotFoundError</span>                       Traceback (most recent call last)
Cell <span class="ansi-green-fg">In [4], line 2</span>
<span class="ansi-green-intense-fg ansi-bold">      1</span> # test case: branch graph
<span class="ansi-green-fg">----&gt; 2</span> from FRED.graph_datasets import CycleGraph
<span class="ansi-green-intense-fg ansi-bold">      3</span> A = CycleGraph(num_nodes=10)

File <span class="ansi-green-fg">~/Projects/FRED/FRED/graph_datasets.py:405</span>
<span class="ansi-green-intense-fg ansi-bold">    401</span>         plt.show()
<span class="ansi-green-intense-fg ansi-bold">    404</span> # Comes from 01c Plotting Utils.ipynb, cell
<span class="ansi-green-fg">--&gt; 405</span> from .datasets import display_galary
<span class="ansi-green-intense-fg ansi-bold">    406</span> import torch
<span class="ansi-green-intense-fg ansi-bold">    407</span> def display_heatmap_galary(dataset, ncol=4):

File <span class="ansi-green-fg">~/Projects/FRED/FRED/datasets.py:701</span>
<span class="ansi-green-intense-fg ansi-bold">    697</span>     return X, flows, labels
<span class="ansi-green-intense-fg ansi-bold">    699</span> # Cell
<span class="ansi-green-fg">--&gt; 701</span> import scvelo as scv
<span class="ansi-green-intense-fg ansi-bold">    702</span> import torch
<span class="ansi-green-intense-fg ansi-bold">    704</span> def rnavelo_find_cluster_key(adata):

<span class="ansi-red-fg">ModuleNotFoundError</span>: No module named &#39;scvelo&#39;</pre>
</div>
</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">from</span> <span class="nn">scipy.sparse</span> <span class="kn">import</span> <span class="n">csr_array</span>
<span class="n">U</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span>
<span class="n">Usparse</span> <span class="o">=</span> <span class="n">csr_array</span><span class="p">(</span><span class="n">U</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">Usparse</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>(array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4,
        4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6,
        6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8,
        8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9], dtype=int32),
 array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1,
        2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3,
        4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5,
        6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7,
        8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9], dtype=int32))</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">Usparse</span><span class="o">.</span><span class="n">nonzero</span><span class="p">())</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>array([[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4,
        4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6,
        6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8,
        8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9],
       [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1,
        2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3,
        4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5,
        6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7,
        8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9]], dtype=int32)</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

</div>
 

